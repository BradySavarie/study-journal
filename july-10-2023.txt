Today at work I was able to spend a bit of time reading through the mocking lesson from TOP. I have some additional assignments to do however I think I have a handle on the main concepts there. It is pretty much the same as when I learned mocking in Jest.

So far the most helpful piece of information i've gathered on testing as it relates to understanding the workflow behind it is how to follow the arrange, act, assert pattern. Arranging refers to setting up all of the necessary elements/props/etc that need to exist in order for a certain test to take place. Acting is actually taking the action that you are trying to test. Asserting is stating what you expect to happen and then comparing the result with that expectation. For example, perhaps the test that you want to write is whether or not a button changes it's text to a particular value when clicked. First you would arrange the test by setting up a userEvents object and querying for the button. Next you would act by triggering a click event on the button. You would then assert by comparing the result against expectations.

I also decided to take on a side quest to understand Reacts context API as it seems to be cropping up alot in the code i've been viewing recently. I am currently in the middle of a video that is describing how to use the api as well as the pros and cons associated with it. The main problem that is being solved with this api is that prop drilling (manually passing props through several layers of components to reach a target component) is a messy way of handling state management, especially as it increased in complexity. It created unorganized code and requires a lot of manual entry that can cause bugs easily, not to mention it triggers a bunch of unnecessary rerenders because each component will render again when the prop changes even if that component isn't even using it. WHy would you want to pass a prop into a component that isn't using it anyways, right? The only downfall that I can come up with myself (without watching the cons section of the video!!) is that it makes the code less direct and anybody that works on it will not recognize immediately what values are being passed since the chain isn't visible to them.

I understand how to create a context and use a context provider to pass values down to all of the child components within it. It works the same as a themeProvider in materialUI (actually im pretty sure that is built using the context api). When you actually want to use the context you can just destructure the useContext hooks return value, extracting out the context value that you want to access. Some apps will use many contexts so you need to tell useContext which one you plan on using by including it as an argument. The return value is of course the context object containing all of the values you have set inside of it.

The best practice for actually working with contexts is by creating a custom provider component for it that encapsulates all of the context based information within it. So lets say you have a social media application that needs access to the users information in many different parts of the app. The most obvious option would be to just keep the context in the parent component along with all of the logic that makes changes to it, and then wrap the components that you want to receive the context with its provider. This can clutter up the parent component though pretty easily by containing all of the logic within it that relates to the context. Instead you can choose to abstract out that logic into a custom context provider component. You just make a new file, for example UserContextProvider, and then create a UserContextProvider component within it. The component will accept it's children as an input parameter (any elements that are nested within it will automatically be recognized as children and be passed in if you include the { children } object/property). Outside of this component but within the new file you can create the context you will be working with, UserContext. The UserContextProvider will contain all of the state that you want to be included in the context for use in the child components. In this case there could be state that stores values representing authentication (true or false, is the user authenticated?), or just basic user information in an object (with keys such as username, password, etc). There could also be methods that make changes to the state (such as a login method that fetches user information and stores it in userInfo, and then sets authentication to true). Finally, all of the values are then grouped together in a final 'values' object, packaged together neatly and ready to be sent to all of the child components. The component will return the actual context provider now (not that custom component being created), send the values object in as a prop to it, and wrap the children prop in this provider. This approach does the same thing as the first method but it keeps all of the logic encapsultaed within the single component file.