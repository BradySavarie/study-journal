Time to move on with the nodejs course! Unfortunately I have the internet is down tonight, hopefully the tech comes and fixes it tomorrow. Because of that I don't plan on spending time much time watching the videos, don't want my data to go through the roof, but i'm going to review the concepts that I learned yesterday in detail, maybe play around with them a little bit in vscode.

Alright so i've created a nodejs app using everything that i've learned so far. Creating servers, routing, serving html to the browser, handling redirects, and dealing with 404s. I then recreated this same functionality using express so I could get a feel for the differences. Express is pretty awesome, cleans up the code quite a bit. A very basic example of an application but it is nice to work with it regardless. You create a server just by calling express() and listen for requests by calling listen(port). You can the use the get method on the server to handle a get request, and if you want to send html back you just have to use the sendFile method with the path to the correct file. The path is meant to be absolute so you need to include an options object as the second argument if you want to use a relative path just to tell express to use the __dirname as the root of the path. The object only includes the key value pair root: __dirname.__dirname exists in commonJs modules and is just the absolute path to the directory you are currently in. If using ES6 modules this isn't available so you need to use a workaround by creating the variable yourself. It's not hard to do, just create a __filename variable that is the import.meta.url value after being converted to a path. Use the fileUrlToPath method to convert it. Then plug that filename variable in to the dirname method to have just the directory that the file is in returned. This process ends up giving you the directory name, exactly the same as __dirname would be in the commonJS modules. You have to set the type to module though in your package.json if you want to switch over to the ES6 system as it is not enabled by default.

That process may not be necessary as commonJs modules are fine and would result in writing less code in this case. ES6 is more modern though and I prefer it so I may accept that slight tradeoff.. plus I hear it's a bit more performant. Either way is fine.

To redirect to a particular path to a new path you can use the redirect method on the res object and set the path name as the input parameter. Easy peasy.

To handle 404's, rather than respond to a get request using the get method you can call the use method. This method is set to fire on every single get request, but the catch is that it is similar to a default case in a switch statement in that it only ends up running if the code is actually reached. If any get methods are matched before the point in the code that this use method is written than it will not be executed. This works well for 404's because if you put it underneath all of the get requests to routes that you want to handle than those will fire first, and if nothing fires than the use method is reached, executed, and sends a 404 html page as a response within it. The status code is inferred by the sendFile method but there is no way for it to know that the file it is sending is a 404 error in this case, so make sure to set the statusCode to 404 explicitly when doing this. The status() method returns the response object with the updated status code, so you can just chain the command like so: res.status(404).sendFile(etc)

Cool so that's everything that i've learned basically. Moving on now to view engines which should teach me how to work with dynamic data.

