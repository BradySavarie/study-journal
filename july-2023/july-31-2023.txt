Last day of July! I believe that puts me at the 9 month mark of learning to code now which is pretty darn cool. I wish I had known how to use github from day one so I could see exactly which day I started learning, but November 1st of 2022 is my closest estimate. Come a long way from where I started, and incredibly i'm still just as dedicated as I was when I began. When it comes to career aspirations I am pretty used to trying something out and learning that it isn't something that I care to continue with for whatever reason, but that hasn't happened at all with coding. I believe strongly that no matter how long it takes to make this a career it will genuinely be worth it in the end, and since I know how it feels to have doubts about what i'm pursuing this feels really special to me. I've struggled for what feels like my entire adult life to find a suitable career path and i'm thrilled that I think I actually have managed it now. All I have to do is keep working hard and maintaining consistency and I will finally be able to overcome the struggle of starting a real career. The over saturation of the market is intimidating and I know it won't be easy at all when it comes time to look for a position, but i'm preparing well for the challenge so eventually it will fall into place.

Anyways, today i've studied css transitions. I reviewed the four main parameters: property, duration, timing function, and delay. The transition property itself is a short-hand for all of these together, in the order that I listed them. All css properties can be assumed as animatable unless specified otherwise. They have different animation types though which define how the start and end values combine with eachother to create the animation. Types are discrete, by computed value, and repeatable list. If the animation type is discrete than by default the properties switch from the start value to the end value at 50% of the animation progress. It is an instant change at the point in time basically. By computed value is a continuous representation of change basically, so like a smooth transition that uses calculated, in between values. The process in which these values and calculated in determined depending on which property it is. Repeatable list is a little ambiguous to me right now, but seems like a computer value that has several steps within it that are combined into one smooth transition. Don't quote me on that one though.

Next up I looked into stacking context and offset parent. Offset parent is a fundamental concept that I completely missed when first learning about positioning. It basically is the element that another element is being positioned relative to. So if B is being positioned relative to A, you would say that A is B's offset parent. This is useful because it describes what exactly is happening when you are setting position relative and absolute on elements. When saying an element is position relative, you are saying that it is the offset parent of any children elements that are positioned absolutely within it. And if you set position absolute on a child element than it is positioned relatively to the offset parent. Confusing concept because position absolute results in positioning something relative to another element, but nonetheless this is how it works. 

Stacking context is similar to offset parent in that it describes how elements are layered on eachother along the z axis (forward or backwards - how close or how far from viewer), but the concept is a little more in depth. Basically, by default your stacking context is set as the html element. This means that any layering that is happening is been built on top of that html element. In other words, the z index of the html element is 0. It is the lowest element on the pile. You can place a bunch of elements on it and control their position in the stack by setting their z-index values. A variety of actions will result in new stacking contexts being created though. What this means is that the layer that any items within the new stacking context will have a depth that is relative to the new stacking contexte parent. An example of this would be when setting an element to relative and having a child element use it's z-index, you are actually setting the child elements depth relative to the parent now instead of the main html element. This is because it lives within a different stacking context. It can be visualized by imagining laying down pieces of paper one on top of the other. You can decide the overall order of papers in the stack, while also deciding the order of certain papers on top of another piece within that stack. Each of these papers are being used as the base of a different stacking context essentially.

Moving on from that, I learned a bit about writing performant animations. Basically you want to avoid writing animations that are not within the opacity or transform properties. These will almost guarantee that smooth animations occur because they do not trigger layout or repainting in the rendering pipeline, which can cause performance issues and noticeable lag. One caveat is that you need to take stacking context in to mind here because when an animation needs to render it will trigger all elements on top of it within the stacking context to re-render along with it. So if you are animating an element that is on the bottom of a page with lots of elements, the entire page will repaint and cause alot of lag. If instead you make sure that element is all that way at the top of the stack (or as high as possible) than you can ensure that unneceessary repainting is being kept to a minimum.