Okay jumping back into the nodejs course now. Learning about middleware. Apparently it is just all of the code that is ran on the server between receiving a request and sending back a response. I imagine that the possibilities of what you can do with middleware is endless for that reason. Whats interesting is that as soon as a response is sent to the client the code on the server stops being executed. This means that if you have a chain of middleware functions and somewhere in the middle a response is sent back to the browser than the remaining code does not run. So sending a response works sort of like using return within a code block. Anything that is written after returning does not get reached and therefore is not executed.

I learned that middleware does not automatically exit to the next function unless directed to do so. This means that if you don't tell your application to move forward when in a piece of middleware than the client will never receive a response and it will just be hanging there waiting, infinitely loading. The way to tell your middleware function to move on is to pass in the next function as a parameter to the middleware and call it at the end of the logic contained within it. The will exit back and allow the program to continue executing until a response is sent.

I also learned that you can write your own custom middleware, but there is also a ton of 3rd party pieces of middleware available. Some come with express and others you can install via npm. One that I tested out is called morgan which pretty much just logs some details about the request to the console. It's a handy function and to use it is as easy as installing it and calling it within a use function like you would do with custom middleware that you want to run with every request. 

Node.js/Express has an interesting feature where it doesn't automatically make every file available to the public. This means that if you want to include a static file, such as a CSS stylesheet, in the head of your application, it won't work out of the box. The browser will see the link and attempt to access the file, but it won't receive it because it hasn't been designated as a public file.

The default behavior of not making files public by default is primarily for security reasons. It ensures that users don't have access to every file in your project and can't manipulate your project's data without explicit permission from your server.

To make specific files accessible to the public, Express provides a built-in middleware function called 'static.' You can use this function to designate which files should be made available to the browser. Here's how it works: create a 'public' folder and place all the static files you want to be accessible in it. Then, you can pass the 'public' directory to the 'static' function like this: express.static('public'). Express will then know to send these designated files to the browser.

Note that express treats the public directory as the root directory when serving static files, meaning when you link to them you can just do so as if you are linking from the root. For example this is what the stylesheet link tag would look like: 

<link rel='stylesheet' href='/styles.css' />

The href does not say '/public/styles.css' because the public folder is already being treated as the root for the static files.

Time to move on to the MongoDB lesson. Looking forward to this one as it is the last piece of the MERN stack puzzle that I have not touched yet. Obviously express is still very new to me as well but at least a bit of familiarity with all of the technologies is going to be nice to have. Can't wait to get into making projects with them.

I'm getting ahead of myself for sure, but just cause it's on my mind I want to note the next pieces of technology that I plan on learning after I am comfortable with the MERN stack. I want to get a relational database down, and PostgreSQL is looking like a good option. I also want to have a full-stack framework sorted out which would be NextJS. I feel like those will be some really solid skills to add to my repertoire. Also AWS would be great. And just so I can get it out of my head I should really learn Redux. It may not be that useful to me now being that I understand how to use React's context API but many jobs are looking for the ability to use Redux so it may help me stand out more in the future.

Damn so my first 45 minutes or so with MongoDB has been a tad overwhelming haha. I've signed up with my google account to Mongo Atlas which is a cloud data service provider it seems. Within your Atlas account you set an organization and a project. This helps organize the databases that you create. Right now mine are just some placeholder default values. Once you do that you can create a cluster which is a group of servers that work together to provide data services that are reliable and scalable. For example, if one of the servers within the cluster has a hardware failure than you can access the data on another server within that cluster instead. 

Within a cluster you will store one or more databases. A database is a used to organize and isolate data and acts as a container for collections. A collection is a container that you use to group together a bunch of related documents. For example, in a nodejs-practice application you can create a database called nodejs-practice that lives within your mongoDB cluster. Within this databse you can create a blogs collection that stores all of the blog post documents. Each document represents a single blog post and contains data in it like the title, body, etc.

In order to actually use the data storing functionality that mongoDB provides within an application you will need to connect to a cluster. Each cluster has a connection string associated with it that helps identify it and provide the necessary permissions to be able to access its contents. For security reasons you need to create a database user that has a user name, password, and and certain roles that state the actions the user is allowed to take. When connecting to a cluster the user as to be identified. This keeps things secure - not just anybody can access the data and do what they want with it. Knowing that, you need to edit the provided connection string by changing the user and password placeholder parameter values with the credentials of the user that you want to connect. You also need to add the name of the database within the cluster that you are trying to connect to so that the user can be authenticated and therefore receive access to it. Once you have your connection string (which is also called a connection URI by the way) ready, store it in a variable in your nodejs app.

Now you can use Mongoose which is known as an object data modelling library, specifically for nodejs and MongoDB. You don't actually need it but it makes working with mongoDB alot easier.
