Last night I had figured out how basic routing works. I created a practice react app and installed react-router-dom. It seems like a simple concept so far but i'm sure there is a lot of added complexity to it. I just made a few test components and used the router to toggle between them as i updated the pages url. To do this I created a route switch component that is the first component called in my app (so it's located in the index instead of app.js). From there I used a browserRouter to create a few seperate routes that have different paths, and inserted the custom components as the elements that relate to each path. Easy process overall and I can see how beneficial it would be. 

I also learned about the Link component that sends users to a specified path without refreshing the page just like a route does. It is basically a replacement for an anchor tag. A route is similar but it decides which component should be rendered based on the active url path instead of a click event. 

Todays goal is to complete a video assignment on react router that gets a little deeper into the concepts, and then complete the remainder of the lesson hopefully as there shouldn't be too much resource left to sift through.

I looked into React testing at work today out of curiosity and noticed that the odin project recommends building projects with create-react-app which has Jest built in. It goes on to teach you how to use Jest with React by installing an additional library that has extra matchers to use that are relevant to the framework. This is interesting, but i'm pretty set on using Vite as my build tool moving forward so I think I am going to stray from the path a little bit here. Vite is compatible with Jest but it requires extra configuration. It is also slower to run than the built in testing framework Vitest. For tose reasons I think I would benefit more from learning Vitest intead (especially since it uses pretty much the same syntax as Jest from what I can tell, so I already have a certain amount of familiarity with it). I expect to encounter a couple roadblocks since TOP is using different tech but I should be able to make it work. Better for my skillset overall anyways.

Im in the process of learning 5 new techniques for routing that surpass the basics (which are configuring a router, defining routes, and handling navigation). These 5 techniques are:

Dynamic Routing:

    This just refers to defining routes that have custom parameters inside of it that are dynamic (able to be changed). You use the colon symbol in a url to specify that the segment is dynamic, and then give it a name to identify it. The value can be anything really. You then have access to it as a variable by using the useParams hook to destructure out the parameters within the route. for example if you used the path url/:id, then destructuring the params object would look like const { id } = useParams(). what the value of id ends up being then becomes a variable that can be used within the route. Pretty awesome. 

Routing Priority

    Previous versions of react router would run top down and look for exact matches. Dynamic routing doesn't work so well in this case because path/:id would technically match path/someOtherWord. the id variable could be anything, so react thinks they are the same since the follow the same structure and could end up being the same. Routing priority refers to the concept that new version of react router includes which uses clever algorithms to determine which path is most likely to be the one that should be rendered. Paths with hard-coded values have higher priority than dynamic parameters, so a hard-coded value would be visited first if it matches a given path as compared to a parameter that could change. This is similar to css specificity but for navigating through an application. A 404 error route could be defined by setting a path equal to *, which makes anything, because if no other paths match than this route will render the component within it which can show the 404 error. That's an example of route priority at work.

Nested Routes

    This concept is an important one. React router allows nesting - in other words, you can define multiple child routes inside any parent route. This is useful in so many ways! An example is if a collection of routes all share the parent path /books then you can put them all inside of a route that has the /books path rather than include the whole url in each route path prop. Each route within it can then just use its own unique part of the url as its path, such as :id, to render the required component. The parent route won't have an element in this case to render since it is just used to route to child paths, however the keyword 'index' can be used within a child route to specify which element should be rendered if the url matches the parent path. so if the parent route has a path that is /books, and a child route within it has the index value set while the active url is equal to /books than that child route will render its component. This is just a simple use case too, it gets a lot more handy than that. 

    An expansion on nesting would be using it for things like rendering a layout component. Say you have a bunch of components that you want to contain the same set of navigation links. You can copy and paste it into each component, but that is kind of repetitive. instead a good option would be to define a book layout component that defines the jsx layout that you want to render and call it as the element in the parent route rather than leaving it empty. This component will be rendered once the parent route matches the url which means the child components do not get rendered by default. HOWEVER, you can include a component inside of the layout component called Outlet. This component will render out whichever route is within the parent that matches the current url. So you will see the layout component that creates a navigation when the url matches /books for example, but then when you click on a link in the navigation the url will be updated and the Outlet component will sense that the url has changed, then rendering any component within the parent router that matches the new url. Saves a lot of code duplication. You don't actual need to specify a path in the parent by the way if the child components dont share a common path. This is good when you still want a component to be rendered within all these child components that don't share the same path necessarily.

    The outlet component can take a context paramter too, allowing you to pass down data to the outlet path whichever it may be. This works very similar to the context api in react which I need to learn more about. My understanding of it is that you can pass props deeply without needing to specify it at each component level by using context like this. To use the outlet specific context within a route that it is passed to you can use the hook useOutletContext and then store the return value in a variable. This useful when you have a bunch of components that are going to use shared data, because without context you would have to pass it in as individual props to each component which is no fun.

Multiple Routes

    You can render multiple routes, not just one! Ir your url is /books, and there are two routes that contain a matching path, than both will render. This is counter-intuitive because you would think that the first matched route would render only but nope if there are multiple matches then both will come through. This is useful when you have two routers within a component that renders different elements depending on which page you are on. For one router, if the path is /books you may want to render an element that shows the title, while if a different router matches you may want to also render an element that shows a paragraph. These things dont have to be mutually exclusive, they can occur together.

useRoutes Hook

    The useRoutes hook lets you input an array of objects that defines that routes that you want to navigate to using javascript rather than jsx. it accomplishes the same thing as writing up your routes in the jsx as discussed but just looks different. For example, each object in the input array will have path, element, index, etc props avilable to be set just like the Route components do. It is just a different way of representing the same process of routing and can be used if preferable. JSX looks cleaner to me so far, but hey maybe i'll decide to do this instead at some point so its good to know the hook exists.


The next section of the video is all about navigation, and some more functionality of the Link component has been introduced. Turns out it takes more parameters than just 'to' (which specifies the path it links to, obviously). 

Another available prop is replace which is a boolean value that is set to false. By default, when a user clicks on a Link, the new URL is added to the browser's history stack, allowing the user to navigate back to the previous page using the browser's back button. This is known as a "push" navigation. When the replace prop is set to true, it changes the navigation behavior to "replace" instead of "push". This means that instead of adding a new entry to the browser's history stack, the current entry is replaced with the new URL. As a result, clicking on the link will not create a new history entry, and the user won't be able to navigate back to the previous page using the browser's back button. The replace prop is useful in certain scenarios where you want to perform a navigation action without adding a new entry to the history stack. For example, when implementing a login flow, after successful authentication, you might want to redirect the user to the home page and prevent them from going back to the login page by using replace.

The reloadDocument property is simple, it just reloads the entire page instead of just the route that changes. Usually react router will only reload the changes route which is what is useful about it, but overriding that behaviour sometimes is desired.

Finally, state is also available as a prop in the Link component.