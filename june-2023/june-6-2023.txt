So today i've worked through the majority of the props & state lesson. I intend on finishing it off once i'm done my chores tonight. Props are pretty simple, they are just properties passed into components via attribute-like jsx syntax and can be used to share data and functionality. They get stored in a 'props' object and can be destructured or accessed via dot syntax just like any other javascript parameters. Class components and functional components declare props a little bit differently but it's just a variation in pattern, the concept remains the same. 

Using props in class components seems a little bit trickier than in functional components, at least from a syntactical perspective. When creating a class you need to pass the props object into the constructor, and then within the constructor you need to pass the props object into the super method. Class components are extended from the base React components class itself, meaning you have access to all of it's properties and methods within your component. When you instantiate a new class component you can choose to either define a constructor yourself or allow React to create a default one for you:

1 - When you allow React to make one by default it will pass in the props object and then call the super() method with it. This ensures that the instantiation of the component is handled by the parent constructor within reacts component base class, attaching the props directly to it. This is important because it means you have access to the props on the base component object, and you need access to them this way because you are going to be using methods (such as Render) that belong to the base class and most likely will be manipulating or otherwise displaying these properties. You don't necessarily need to pass the props in to the super constructor if you don't need access to them on the base component, however this isn't a very useful thing to do in most cases as you will only be able to use the props on custom methods which limits functionality. That is why the default behaviour works the way it does and is just fine in many cases. 

2 - When you need to configure your component more carefully you can create a constructor yourself instead. Creating it from scratch allows you to do things like use state (which is defined within the constructor), or bind methods to object instances to ensure the context of 'this' remains consistent. Using state is a topic I need to research more before being able to describe it in my own words, but in essence it is a way to set and retrieve the value of variables that change over time. An example would be a count state that begins at a value of zero and increments by 1 each time a button is clicked. You set the default value of count in the constructor, which is then updated later as the button is clicked. This example lends itself to explaing why binding is necessary as well. If you plan on passing a method down as a prop to another component, then binding it first will ensure that the 'this' context will remain as the object instance it was bound to. Passing the click method into a button component AFTER binding it will make sure that when the method is called in the button component the correct values are being manipulated. The button will update the state, but if left unbound then the context would be the button component that it was called in, not the object instance. It would be updating the wrong state basically, or just not have access to it at all.

You can destructure props as well so that you can refer to each key by it's name rather than dot syntax. Nothing new here, standard javascript really.

Where state starts getting powerful is when it is shared among components as a prop. This flow of data is integral to react. The data can only flow in one direction - from parent to child. A child component cannot directly modify data, it is considered immutable, so instead callbacks are passed in as props to the child that when invoked will essentially request that the parent updates the props value. When the value is updated it triggers re-render of the particular component which in turn passes down the updated state to it's children. This is what makes the way that React handles state so brilliant: it is managed centrally by the parent and accessed/updated by it's children on request resulting in a one-way flow of data from the parent to the child. This simplifies the data model so much and makes reasoning about your application logic much more intuitive.

Okay the state and props lesson in complete! I feel pretty good about it. Next up is getting some actual practice in. I'm going to be writing a basic React application that handles input and renders a list. Very easy stuff but definitely will be worth doing to get my confidence up and work through some inevitable holes in my knowledge. For this 'project' I will use create-react-app to get a better feel for the dev environment it sets up for me and the tooling it provides. For the next actual project I make though I can see myself exploring Vite instead as it seems like a stronger alternative.