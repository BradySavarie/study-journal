So far today I've read 2 articles - the first about rebasing and the second about reset. The rebasing article was a recap on the functionality of it and honestly was kind of ovewhelming. I'm going to look for some more resoures in addition to what TOP is providing to make sure I understand how to properly use these commands. I believe I will need to spend more time on this than I anticipated because I really want to ensure I know how to use these commands.

I'm going to explain rebase and reset in my own words to see how well I understand it and then go try and fill in the gaps tonight. Hopefully I will have the first lesson complete. 

Rebase is a command thats main purpose is to combine the history of two git branches (same purpose as merge, but the method of doing so is different). As opposed to merging the histories onto a new commit, it copies the source branches history all the way back to the point of divergence and inserts the copies on top of a destination branch, creating a linear chain of commits. This is useful because the outcome tells an easier to comprehend story about the changes that happened within a repository than a merge would. It is not a perfect representation of the order of changes though (like a merge would be) because the source branches commits are placed in front of the destinations even though they could have been written before the most recent commit on the destination branch. The rebase command has many options, including an interactive tool that allows you to go back and rewrite history entirely. Typically rebase will be used to take a branch and combine it's commit history with another as described, but if the goal is instead to just edit some old commits than rebase can be used for that too. Instead of moving HEAD (the reference to the current commit being viewed on the active branch) to point to a different commit, it can stay pointed where it is. Using the interactive tool a rebase can be ran to make edits to the chosen commits as far back as necessary (by telling it where to stop). This is super useful when its not just the most recent commit that needs amended.

Reset is a command thats purpose is to undo a mistake. The approach it takes to do this is it changes the HEAD of the branch to point to the commit that the mistake was made on, and then depending on which reset option is being used the staging area and working directory are adjusted to reflect the desired changes. For example, the --soft option keeps everything in the index/staging area and working directory in tact which is great if you plan on recomitting the changes. The default option (also called --mixed) clears out the staging area but leaves the working directory as is. This allows you to manually choose which changes are to be committed again. The --hard option also sets the working directory back into the stage it was in when the target commit was made. This is dangerous because data can be lost, but it has its use cases. An analogy for this method of undoing mistakes is taking a wrong turn and then driving back to the intersection to continue on a different path. All progress is lost but the mistake is fixed.

Revert is also meant to undo mistakes but instead of moving back in history and brand new commit object is created that undoes the changes in the specified commit. This preserves history while still resolving the problem. It is like taking a wrong turn but once realizing it you cut down a side road that leads back to the correct location. Instead of going back in history you take a new path forward to solve the problem.

I want to make a quick note here as well about git push --force-with-lease to ensure I remember the command. It is git push --force, which completed overwrites the contents of the remote repo with the local repo being pushed, however it is fail-safe because if any updates have been made to the remote repo it will notify you and throw and error. Some companies use this as their default push method.

Okay I feel pretty darn good now with everything i've learned in this git lesson! I have a much better grasp on how git functions than I did previously, and it feels significantly less intimidating to navigate. I have learned how to properly use and visualize branches and combine them in different ways. I've learned how to rewrite both recent and old history. I've improved my comprehension of remotes and how to push and pull from them more effectively. I've learned about the dangers of certain commands and how to avoid destroying others work as well as my own.