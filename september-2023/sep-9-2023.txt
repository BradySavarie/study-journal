Okay jumping back into the nodejs course now. Learning about middleware. Apparently it is just all of the code that is ran on the server between receiving a request and sending back a response. I imagine that the possibilities of what you can do with middleware is endless for that reason. Whats interesting is that as soon as a response is sent to the client the code on the server stops being executed. This means that if you have a chain of middleware functions and somewhere in the middle a response is sent back to the browser than the remaining code does not run. So sending a response works sort of like using return within a code block. Anything that is written after returning does not get reached and therefore is not executed.

I learned that middleware does not automatically exit to the next function unless directed to do so. This means that if you don't tell your application to move forward when in a piece of middleware than the client will never receive a response and it will just be hanging there waiting, infinitely loading. The way to tell your middleware function to move on is to pass in the next function as a parameter to the middleware and call it at the end of the logic contained within it. The will exit back and allow the program to continue executing until a response is sent.

I also learned that you can write your own custom middleware, but there is also a ton of 3rd party pieces of middleware available. Some come with express and others you can install via npm. One that I tested out is called morgan which pretty much just logs some details about the request to the console. It's a handy function and to use it is as easy as installing it and calling it within a use function like you would do with custom middleware that you want to run with every request. 

Node.js/Express has an interesting feature where it doesn't automatically make every file available to the public. This means that if you want to include a static file, such as a CSS stylesheet, in the head of your application, it won't work out of the box. The browser will see the link and attempt to access the file, but it won't receive it because it hasn't been designated as a public file.

The default behavior of not making files public by default is primarily for security reasons. It ensures that users don't have access to every file in your project and can't manipulate your project's data without explicit permission from your server.

To make specific files accessible to the public, Express provides a built-in middleware function called 'static.' You can use this function to designate which files should be made available to the browser. Here's how it works: create a 'public' folder and place all the static files you want to be accessible in it. Then, you can pass the 'public' directory to the 'static' function like this: express.static('public'). Express will then know to send these designated files to the browser.

Note that express treats the public directory as the root directory when serving static files, meaning when you link to them you can just do so as if you are linking from the root. For example this is what the stylesheet link tag would look like: 

<link rel='stylesheet' href='/styles.css' />

The href does not say '/public/styles.css' because the public folder is already being treated as the root for the static files.

Time to move on to the MongoDB lesson. Looking forward to this one as it is the last piece of the MERN stack puzzle that I have not touched yet. Obviously express is still very new to me as well but at least a bit of familiarity with all of the technologies is going to be nice to have. Can't wait to get into making projects with them.

I'm getting ahead of myself for sure, but just cause it's on my mind I want to note the next pieces of technology that I plan on learning after I am comfortable with the MERN stack. I want to get a relational database down, and PostgreSQL is looking like a good option. I also want to have a full-stack framework sorted out which would be NextJS. I feel like those will be some really solid skills to add to my repertoire. Also AWS would be great. And just so I can get it out of my head I should really learn Redux. It may not be that useful to me now being that I understand how to use React's context API but many jobs are looking for the ability to use Redux so it may help me stand out more in the future.

Damn so my first 45 minutes or so with MongoDB has been a tad overwhelming haha. I've signed up with my google account to Mongo Atlas which is a cloud data service provider it seems. Within your Atlas account you set an organization and a project. This helps organize the databases that you create. Right now mine are just some placeholder default values. Once you do that you can create a cluster which is a group of servers that work together to provide data services that are reliable and scalable. For example, if one of the servers within the cluster has a hardware failure than you can access the data on another server within that cluster instead. 

Within a cluster you will store one or more databases. A database is a used to organize and isolate data and acts as a container for collections. A collection is a container that you use to group together a bunch of related documents. For example, in a nodejs-practice application you can create a database called nodejs-practice that lives within your mongoDB cluster. Within this databse you can create a blogs collection that stores all of the blog post documents. Each document represents a single blog post and contains data in it like the title, body, etc.

In order to actually use the data storing functionality that mongoDB provides within an application you will need to connect to a cluster. Each cluster has a connection string associated with it that helps identify it and provide the necessary permissions to be able to access its contents. For security reasons you need to create a database user that has a user name, password, and and certain roles that state the actions the user is allowed to take. When connecting to a cluster the user as to be identified. This keeps things secure - not just anybody can access the data and do what they want with it. Knowing that, you need to edit the provided connection string by changing the user and password placeholder parameter values with the credentials of the user that you want to connect. You also need to add the name of the database within the cluster that you are trying to connect to so that the user can be authenticated and therefore receive access to it. Once you have your connection string (which is also called a connection URI by the way) ready, store it in a variable in your nodejs app.

Now you can use Mongoose which is known as an object document mapping library, specifically for nodejs and MongoDB. You don't actually need it but it makes working with mongoDB alot easier. It basically helps to define the structure of your data and provides a familiar object-oriented interface for working with it. When using mongoose you create things called schemas and models. A schema is essentially a way to describe the structure of a document, kind of similar to working with interfaces in typescript. Within the schema you describe the properties, property type, and other options that are in the document. So in a blogSchema, you would have a title that is a string and is required. Move on down the title to the snippet, body, etc. Now a model on the otherhand is what you can actually use to interface with the documents. It is given a schema that is conforms to and contains methods for actions such as writing, reading, updating, and deleting documents. So a Blog model would allow you to communicate with database collections, specifically that contain documents conforming to a blog schema.

In a project you would probably have a folder called models that stores all of the (you guessed it) models. I'll walk through an example of what creating a blog model would look like. First you would create a file called blog.js that will serve as the blog model. Making sure mongoose is installed in the project first, you will require mongoose in the file. You will also need a constructor function called Schema that mongoose provides, so store that in a variable as well called Schema. Next you want to make the schema that the blog model wraps around. Do so by creating a constant called blogSchema that is equal to a new intsance created by the Schema constructor. Within the constructor pass in an object that will define the structure of the blog data. Just key value pairs that describe the data is good. An options argument can be used as well as the value so that you can provide more info about the property such as whether or not its required. Once the blog schema is created, pass a second argument into the constructor that is an object with a timestamps property set to the value true. This just makes sure that whenever a new instance is created or updated or whatever that a timestamp is added to the action for future reference.

Now you can create the model by just calling mongoose's model method. This method takes two parameters. The first is the singular version of the name of the collection. So if you have a collection called blogs, than you want to put the value 'Blog' here. This tells mongoose to look in the blogs collection. It is smart enough to know what the plural version is so that it can identify the collection that you are creating a model for which is pretty cool. The second parameter is the blogSchema that was created previously. This model method then returns the Blog model that can be exported and used in the application to interact with the database.

Great so now that a blog model exists it's time to try it out. Import it in your nodejs app and create a new get handler that looks for requests from the route /add-blog. When this request comes in, create a new blog object using the model and store it in a constant called blog. All you have to do is use the model like a constructor and pass in an object with the expected properties like title, snippet, and body to do so. Once you have the blog object ready you can save it to the database really easily by saying blog.save(). This method is async so anything that you want to do with the data once it is saved should be executed only once the promise is resolved. In this case if you want to just see the contents of the document that is created you can tack on a then method after the save method. It will receive a result and you can pass that result to the browser by saying res.send(result). This will display the new document in the browser. If you open up MongoDB Atlas and look at the collection you will see that new document saved within it. Pretty awesome. Note that that reesult that is being sent to the browser is not the exct object that was created in the nodejs app, instead it is the one that was created by mongoDB when saved. It includes a unique ID and some timestamps in addition to the properties that were initially created. 

In addition to saving documents you can do alot more with mongoDB/mongoose. You can also find all the blogs or just a blog by its ID for example. The first method find() returns an array of all of the documents within the blogs collection, while findById() with the unique ID input as a string parameter will return just that blog document that matches. Really easy interface to work with so far. Note that these id's are not stored as strings by default by the way, its mongoose that is converting it to and from strings when necessary in order to handle the data properly which is convenient.