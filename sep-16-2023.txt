I ended up completing the unit on Indexes in MongoDB yesterday evening. It was definitely the most challenging unit for me to understand yet. I think the reason I was struggling to wrap my head around it is because the main purpose of using an Index is to improve performance and I am not used to thinking from that perspective yet. I'll recap the details:

In MongoDB, an index is an ordered data structure that is designed to make accessing specific subsets of documents much more efficient. Instead of scanning an entire collection when a query is made, you can set up an index to locate and access documents that match a specific criteria. So for example, say you created a username index. When you make a query to find user names that match a certain value, by default mongoDB would parse through each document to check if that field matches. Scanning every document in the collection can be slow though, especially at scale. An index will store the value of the usernames in an ordered data structure like a binary tree for example that is very quick to parse through in comparison to scanning entire documents. The values that match will then be returned. So regardless of what query you are running this process of looking through an index can make dramatic improvements for performance.

I learned about single-field and compound-field indexes. Single field is as it sounds, the index just stores a single fields value. Compound would instead store a document with more than one fields. The username example above would be considered a single-field index and would be useful when it is very common to make query's based on usernames. A compound-field index would come in handy when you have a situation where you tend to make query's based on several fields together, such as looking for a person by first name and last name. In compound-field indexes each field has it's own sort order which can affect how efficiently the data is traversed. 

If an index contains an array than it is said to be a multikey index. Compound indexes can only contain one of these. Having the ability to support searching through arrays is great but it can require quite a bit more resources that eat up storage and write speeds. Which brings up an important topic!

The tradeoff of using indexes in the first place is that write speed is degraded and storage requirements are increased. This comes with the benefit of query performance so you need to strik a balance that works best for the application. Write speed is affected because indexes store many different index fields which need to be updated any time a CRUD operations affects that data that it points to. These index fields of course require storage to persist.

Creating an index is easy, just call the createIndex method and pass in the field(s) you want to create an index for along with each fields sort order (ascending or descending). You can view all indexes by calling getIndexes. If you want to know whether or not a specific query is using an index you can chain on the explain method to the query and you will be get to view the stages that the query takes to retreieve the data. If an index is being used it will be visible there.

