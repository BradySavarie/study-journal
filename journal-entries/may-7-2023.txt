Last night I watched a few pretty lengthy videos in a series about mocking. I see the purpose of it for sure, however i'm about to dive into why it may not be appropriate to use it for many situations. I will report back with my findings haha.

I read a very long article on mocking that talked quite a lot about why it is not always a great thing to do for unit tests. Sometimes needing to put together elaborate mocks is an indication (or a code smell) that maybe the design pattern itself needs to be refactored to reduce coupling. Obviously this is now always possible, and mocks aren't something to be completely avoided, but there is defintely a point of diminishing returns and too much time spent on them could be time that is better spent working on the code itself. 

I'm personally going to be a bit skeptical of the last paragraph and whether or not I understood the article that I read correctly. It was a very 'scholarly' article and lot's of it went over my head at this point in time, so maybe I misunderstood what the author was getting at. It's good to keep in the back of my mind that if i'm writing these elaborate mocks that perhaps there is an opportunity for improvement so that's what i'm going to take from the article. Now it's time to watch a talk on writing good unit tests called 'The Magic Tricks of Testing' by Sandi Metz. 

Sandi has made an important distinction between types of messages: queries and commands. a query is a message that has no side effects, it just asks for something back given certain conditions. For example a calculation is a query. You ask what is 2 + 2 and are provided the response 4. A command on the other hand doesn't return anything but instead makes changes to something based on instructions provided. Like 'store this a value in a database" would be a command. Something can be both a query and a command at the same time. An example of this is popping an item out of a queue. This item is often returned, but it still changes the 'state' of the queue. It is a query and a command. 

Queries and commands should be tested differently. It is also important to know the origin of the message though in order to know how to test it. Messages can be incoming, sent to self, or outgoing. Thinking from a perspective of black box testing incoming messages are what the black box receives to do work on, self-sent messages are messages that are created and contained within the black box, and outgoing messages are what is being transmitted from the black box. 

Incoming queries can be tested by checking the validity of an assertion made on the output value. For example, an incoming query is 2+2 and your test makes an assertion that the output will be 4. If this assertion passes the test than the black box if functioning as expected, otherwise it is not working properly. Simple as that. test the interface, not the implementation.

Incoming commands are testing by making an assertion about the expected side effects. It is very similar to how queries are tested by checking the results. For example, if a variable is updated by a command than a test will be ran to check whether the value of that variable matches what would be expected on a given input.

Any queries and commands that are sent to self by a function actually don't need to be tested at all. It is advised to ignore them (unless the error messages are genuinely helping for development purposes). The reason for this is the are redundant and can actually make refactoring downright impossible. If other units tests are passing from the outside perspective, than why bother testing the internals? This makes the code more fragile because when refactoring comes along they will likely break, and it just makes the refactoring process a pain when tests are constantly breaking. When it feels like writing these tests are helpful in developing the code itself, the best thing to do would be to either delete them afterwards or move them to their own self-contained module that has a comment saying 'if these break, delete them'. This can save alot of resources in the future while still serving the purpose in the meantime.

Interestinly enough, outgoing query messages also should not be tested due to redundancy. Thinking about it, one outgoing message is another modules incoming message. Right? So if you are testing outgoing queries as well as incoming than the exact same tests are being ran twice basically. No point in that.

Outgoing commands can simply be tested by expecting them to be sent. That's it. Whether or not they were in fact sent is all that matters in this case. Another black box will receive it is an incoming command which means it will have side effects, and it is tempting to test those side effects with assertions. This creates dependencies across multiple modules however if the side effects happen quite a few steps down the line. This type of test therefore would be an integration test, not a unit test. The original function that sends the outgoing command should not be concerned with doing the thing, it should be concerned with sending the message. Testing whether ot not a message was sent can require a mock for the sake of stability and efficiency.