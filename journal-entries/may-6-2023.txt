I got a practice test written yesterday with Jest. Not so difficult, and I didn't even need to install and configure Babel as expected to get it working. Today's goal is to work through the 4 remaining practice functions for testing, and then potentially begin the next git lesson. Let's gooo!

I just wrote a reverse string function using built-in js methods split, reverse, and join. I wrote a test for it first that expects 'brady' to be 'ydarb'. It helped me trouble shoot the code pretty well by telling me the result vs expect output - it's like having a console.log ready to go at all times. Love it so far. 

Now i've written a test suite that checks if 4 basic methods (add, subtract, multiply, divide) on a calculator object work. Pretty easy, even though I somehow got a little tripped up on creating an object that contained methods. I've been getting too used to class syntax.

Time to write a caesar cipher now. It should take a string and a shift factor and then return a string that has been shifted by that amount. 

After messing around with hard-coding alphabet arrays I think i'm going to take an approach that utilizes each character is the plaintext's ascii value to produce a cipher.

Okay caesar cipher is good to go, all tests pass. I'm getting the hang of testing for sure. In regards to the function itself, i passed in a string and a shift value. an empty cipher string is initialized. For each character in the input string I stored the character in a variable. I used a regex to test if it is a letter (upper or lower), and if so I used the charCodeAt() method to store its ascii code. if the code is within ascii lowercase range I calculated its new charCode by subtracting the lowercase a ascii value from it, adding the shift value to the new normalized value, took mod 26 of that number, and added back in the lowercase a ascii value. This process provided a new ascii code that I converted into a string character and appended to the cipher. This process repeated for each letter and the cipher string was returned at the end.

To clarify, I had to normalize the ascii character values to be able to wrap the code around the alphabet using a mod calculation. Since ascii values for letters start at 65 for uppercase and 97 for lowercase, if I was to take the mod of these I would not be wrapping around a 26 letter alphabet. Thats why i first took the difference away to work with a 26 character range starting from 0, then doing the shift and mod calc from there, and finally adding the difference back in to find the correct ascii character. Kind of a tricky concept at first but it results in what I think is a clean version of the caesar cipher.

Nice, just wrote the last practice test pretty easily. I only had to write an analyzeArray function that returned an object with min, max, average, and length properties that are calculated based on an input array. Easy stuff but it confirmed that I am getting this whole testing thing down. I would like to move on from the basics and explore the variety of matchers that are available however I think I may continue on the git section before doing that.

Okay I kind of just decided to move on at random with the TDD section. This next part has been focused on pure functions and mocking. Pure functions are basically just functions that will always return the same output given the same input. In other words, there is no code that is external to the function that can cause the function to break in any way. If the input a results in b now, it will always result in b no matter what. Not only this, but the function also does not produce any side effects such as mutating data or making an http request. TDD encourages writing pure functions because consistency and speed are important qualities for a test to have and pure functions provide exactly that.

That leads into what mocking is and why it can be greatly beneficial when writing tests. Mocking is the practice of a writing a fake test that always behaves exactly how you want it to. You do this because sometimes the way that the actual function operates will by necessity require something like an api call, or DOM manipulation, and this type of work takes time and resources to complete. Sometimes the time and resources aren't available (no internet connection for a api call for example), or it's just too darn inconvenient to write all of the code now to test if it will work once it's written. Writing a mock function that will always provide the expected output allows you to ensure that the function will in fact operate properly (pass all tests) once it is hooked up completely.