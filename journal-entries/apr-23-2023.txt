I'm drilling the sorting algorithms again by memory in a starbucks right now. It's alot of fun.. can't help it. Yesterday I managed to do bubble sort, insertion sort, selection sort, and merge sort. Today i've done insertion sort by memory and I think i'm going to work on the others a little bit as well before proceeding with the odin project. It feels good to train my problem solving skills.

Okay i've implemented bubble, selection, and insertion sort again today so i'm feeling pretty good. I've spent the most time over the past few days on merge sort so i've decided to forego it today. I still would like to learn quick sort but i'm going to prioritize the current lesson that i'm on for the odin project before focusing on that.

Just finished up the data structures and algorithms lesson. Topics discussed include stacks and queues, binary search, and binary tree traversal (both breadth-first and depth-first). Stacks and queues are just abstract data types that store elements and allow access to them based on 'time of insertion' basically. The last element that is put into a stack will be the first element that gets output. It is like putting marbles down a tube or whatever; if you turn the tube upside down than the last marble you put in will be the first to fall out. In a queue the first element that you put in will be the first to be output. An analogy for this is like standing in line at the grocery store. Whoever gets there first gets served first.

These concepts are pretty basic but its good to formally recognize the difference because they come in very handy in the next topic. Binary search is basically an divide and conquer style algorithm that recursively divides its input in half (creating a binary tree) and searches through each section methodically to find the target element. In a breadth-first type of search the algorithm will look at all of the children of a parent element before moving on to the grandchildren. This is essentially a leveled-order approach where it searches one level in the tree at a time, starting with the root node of the tree at level 0 and moving to its children at level 1 and so forth. A depth-first style of algorithm instead will drill down to the deepest level of the tree before it begins searching. It can be implemented 3 different ways: pre-order, in-order, and post-order. This refers to the order in which the algorithm reads the data. If it reads the root first, then it's left child, then it's right child that is considered pre-order because the root is checked first. In-order means the left is checked, then the root, then, the right node before moving back up the tree to the parent node. Post order is obvious now, the root is just checked last. 

This whole concept of depth-first binary tree traversal is really helpful in visualizing the process of recursion and what specifically is happening to the callstack. breadth-first is a good example for when queues are more beneficial than stacks.