Today i'm going to be studying asynchronous programming. Just last night I learned about the topic itself and todays goal is to read a chapter from 'You Dont Know JS' about callbacks so that I can really solidify how they work in my mind. I'm already feeling pretty comfortable with them now but I now just how excellent this book is so i'm sure I will learn some new things and it never hurts to get in the repitition. If I get through it all today than I will be ready tomorrow to read the chapter on Promises. 

I'm pretty excited about the concept overall. It was neat to learn yesterday that Web API's are run separate from the javascript runtime thus allowing the code to continue executing while it does its work. The video that I watched that taught me how these resolved/rejected API calls end up in a task queue which is then tossed back onto the callstack by the event loop once the stack is empty was very helpful for understanding how this can all work. A notable concept was that setTimeout functions can be a very useful way to control the execution order of functions by tossing them into the task queue and therefore controlling the executable codes position within the call stack. 

I decided to actually read chapter 1 of the async 'You Don't Know JS' book instead and there seemed to be alot of references to this chapter right away. I'm glad I did as it set the founcation for thinking about callbacks and reiterated how the event loop works. I'm a little confused right now and how the job queue differs from the event queue though so ill need to try and clarify that bit.

Nvm I just asked chatgpt and it cleared things up in a matter of minutes. Turns out the job queue is run on the same tick-based system as the event-loop queue. The only real difference is that the event loop queue checks the job queue first to see if there is anything there to execute and if so it will execute it before moving on to the next task in the event loop queue. This helps ensure higher priority actions are taken care of first (for example, a UI updating on user scroll) as opposed to having to clear out lower-priority things first (such as executing a callback of some kind that may take a moment to process thus causing a UI that lags behind).