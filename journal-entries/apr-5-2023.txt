Today i'm going to be studying asynchronous programming. Just last night I learned about the topic itself and todays goal is to read a chapter from 'You Dont Know JS' about callbacks so that I can really solidify how they work in my mind. I'm already feeling pretty comfortable with them now but I now just how excellent this book is so i'm sure I will learn some new things and it never hurts to get in the repitition. If I get through it all today than I will be ready tomorrow to read the chapter on Promises. 

I'm pretty excited about the concept overall. It was neat to learn yesterday that Web API's are run separate from the javascript runtime thus allowing the code to continue executing while it does its work. The video that I watched that taught me how these resolved/rejected API calls end up in a task queue which is then tossed back onto the callstack by the event loop once the stack is empty was very helpful for understanding how this can all work. A notable concept was that setTimeout functions can be a very useful way to control the execution order of functions by tossing them into the task queue and therefore controlling the executable codes position within the call stack. 

I decided to actually read chapter 1 of the async 'You Don't Know JS' book instead and there seemed to be alot of references to this chapter right away. I'm glad I did as it set the founcation for thinking about callbacks and reiterated how the event loop works. I'm a little confused right now and how the job queue differs from the event queue though so ill need to try and clarify that bit.

Nvm I just asked chatgpt and it cleared things up in a matter of minutes. Turns out the job queue is run on the same tick-based system as the event-loop queue. The only real difference is that the event loop queue checks the job queue first to see if there is anything there to execute and if so it will execute it before moving on to the next task in the event loop queue. This helps ensure higher priority actions are taken care of first (for example, a UI updating on user scroll) as opposed to having to clear out lower-priority things first (such as executing a callback of some kind that may take a moment to process thus causing a UI that lags behind).

Just finished up chapter 2! It provided a good explanation of what callback hell really is and why it should be avoided at all costs. The problems run alot deeper than just difficult to read, triangle of death style code. Trying to think of asynchronous tasks in a synchronous way in general just doesn't seem to mesh well with the way our brains our wired. Our brain works by switching contexts very quickly rather than actually doing two processes at the same time (synonymous to async event-loop style behaviour). On an operational level this is in fact synchronous, but thinking about it that way can really overcomplicate things quickly. They also introduce alot of problems with inversion of control. If third-party resources of any kind are allowed to take over control of how our code executes than many unforseen issues can occur, and writing code using callbacks like this encourages the develop to try and solve all of these potential problems by writing defensively for each particular problem. But the developer can't know about every potential issue before it happens and they are likely to get bitten by a bug regardless of all of the defensive planning. 