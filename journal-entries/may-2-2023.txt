I'm currently at a coffee shop about to get going on the intermediate git section of the odin project. Yesterday I looked further into Array.from() and iterables to make sure I understood what exactly I was doing while creating the adjacencyList and predecessors arrays in the knights travails project. 

Oh also I met a guy today who does web development. Technically he is a brand coordinator for Vianet, but part of his job involves web dev which I think it cool. He has a bunch of years of experience in print/signage which I find interesting as well. If I see him again, which I bet I will because he has ordered from Duplicators in the past and dealt with Jake, I think it will be a good call to tell him i'm looking to transition into a similar role as him and i'm really curious about how he leveraged his experience in print to get where he is now. Maybe he will be down to chat with me about it sometime over coffee or whatever.

So far today i've gotten the chance to learn and practice a few useful git commands. Right now I know for sure that i'm comfortable with init, add, commit, status, log, push, and pull. I use those commands all the time. I learned that adding the -u flag when pushing to github sets the upstream branch for the local branch. This means that I don't need to specifiy the brach that I am pushing or pulling the local branch to everytime I run those commands like I have been doing. Handy litle trick. 

I am getting more familiar with using branches in my git workflow as well. I know I can create a branch using the git branch <branch-name> command, and that I can switch between branches by using the checkout command. I can use the -M flag inside this command to rename the branch and overwrite it if the branch already exists. Useful if renaming the default 'master' branch to 'main'. I am less comfortable with merge, however I do understand how it works and should use it more often. Basically i need to checkout to the destination branch and then run git merge <source-branch> to merge two branches together. Then if there are no merge conflicts I just commit the merge and all is well. To keep the repo tidy I can then run git branch -d <source-branch> to delete the branch. If it has already been fully merged this will do the trick, but if it hasn't and I want to delete it anyways I can just use the -D flag instead to force it's deletion. To check which branch im on at any point in time I can use git status, or if I want to see all branches i can run git branch -a.

Anways that is all stuff i've learned and retained from the past. The following is stuff i'm just using today. 

The first new command that i've learned is a modifier of git commit called --amend. This command doesnt just change the last commit but instead merges all of the changes within it and the current working directory together and then completely replaces it with those changes. Important to note that ammending commits that have been pushed should be avoided because the commit will be replaced with a new one. If you're on a dev team and someone is basing their code off of that commit then any changes can potentially screw them over/break their code.

Next I learned about rebase which is handy when it is not just the last commit that needs to be changed. It is called rebase because you are essentially reapplying a series a commits onto a base commit. You are basically looking back in history and making changes at specified points in a chain of commits. If you use the -i command an interactive mode is enabled which makes a file pop-up that you can make edits in. In this file we can remove, reorder, and otherwise make changes to previous commits such as updating the commit message. The file lists the options that ae available within rebase for reference. When running the command we have to tell it which is the last commit we want to edit. For example, HEAD~2 will allow us to edit the last 2 commits (HEAD being the most recent), or inputting --root (the first commit made) will make all commits available for rebasing. Once the chain of commits is defined we can use the interative editor to make whatever changes we need to make. An example of one that I used today is the edit option, which takes the commmit that you called edit on and stops the rebase at that point (making it available for edits). Since the rebase it waiting I ran git commit --amend to change that commit message, and then I ran git rebase --continue to let the rebase command move on. It's not too tricky really, especially after working through that linked list data structures lesson recently and understanding that each commit is basically an object containing a set of data and is pointing to the previous commit like a linked list would do.

Once I got comfortable with rebase I learned how to use it to squash commit. This means taking a commit and basically squashing it into another one (merging its data into the one after it and then deleting the squashed commit). This tidies things up by condensing a long chain of small commits that isn't necessary in the big picture. A dev could waste time reading all of these cluttered commits when instead it could all be squashed (condensed) after the fact into one bigger commit with a defined purpose. It's like writing bullet points in your journal saying 'shit', 'showered', 'shaved' and then realizing later that is probably tmi so you cross it out and instead write 'freshened up'. haha. Apparently squashing is a standard on many dev teams so it's going to be good to know.

I just looked further ito rebase and came across several sources comparing it to merge. Supposedly the both are accomplishing the same task - combining branches. The approaches however are different. A merge will preserve the branch history of the feature that is being combined with the main branch. When visualized this looks like a parallel circuit that splits off and then reconnects basically. Both branches will have commits along them, and then a new commit 'node' will be created on merge that takes the information contained within the most recent commit on each branch and combines them together into a new commit. A rebase on the other hand will instead combine branches by taking all of the commits in a source branch and 'basing' them on top the most recent commit in the destination branch. When this rebase is done it rewrites hsitory so to speak to look like everything was done in a linear fashion, and a way to visualize this is by imagining a parallel circuit that is disconnected where the circuit splits off and then placed back on top of the other path but in series instead. Hope that is clear. Note that the commits on the source branch are copied onto the base of the destination branch, not moved there. Looking at the commit ID's will show that they are in fact new commits.

Now i'm learning about splitting up commits using a combination of the rebase and reset commands. So reset takes the head and moves it to the specified location, and then restages staging area to the contents of that commit. Rebase will allow you to choose which commit we are applying the reset command to by changing pick to edit on said commit. This means that i can select a commit that I want to split up using rebase, change it to edit, and then reset to the parent commit of that selected commit using git reset HEAD^. This will reset the staging area and allow you to choose which changes are being committed. Letting the rebase continue afterwards will result in a perfectly split up commit history.

