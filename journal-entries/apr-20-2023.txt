I finished the recursion module last night and it was super fun and interesting. I had the opportunity to practice recursion by focusing on writing a fibonacci function and a merge sort function. The fibonacci one was pretty easy surprisingly, I had written it within maybe half hour or so. The merge sort on the other hand definitely required some studying and analyzing other code to see how the algorithm ticks. I have written it several times now from memory and I have a solid understanding of how it works. I think I might go write it again as a fun exercise to make sure it stuck.

The most recent topic I am studying is asymptotic notation, which is essentially the way in which you communicate the performance characteristics of an algorithm as it scales. Big O notation in particular is the main focus, and it describes the worst case scenarios for how an algorithm performs from a time complexity standpoint as the input size approaches infinity. There are 8 Big O notations that are discussed in the course and my main goal right now is to comprehend each of them and learn how to analyze the time complexity of an algorithm so that I can determine how it will perform. This should help me understand which algorithms to apply to certain situations and which should be avoided for performance reasons. 