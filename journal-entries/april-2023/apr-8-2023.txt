Alright so i've had the chance to digest what i've learned last night in the Promises chapter and I think i'll recap it all quickly to solidify what I actually retained. The definition of Promises themselves is covered in my last entry and I think I have a good grasp on what they are and the problems that they help solve. Everything below represents more details and nuance.

The first major section of the chapter explained all of the reasons why a Promise is more trustworthy than a callback. Un-inversion of control is the reason behind this (discussed in my last journal entry), and the problems it solves are invoking the callback too many times, not enough times/never, too early/late, not passing any parameters due to a failure, and swallowing errors. That is quite a lot of issues being solved via one paradigm, and while the problems won't always present themselves it certainly is nice to have safeguards in place in case they do. Hence the improved trust in the code.

Another concept that was covered is thenables. Any object that has a .then() method on it is considered a thenable, and it can be used to handle fulfillment and rejection of asynchronous operations. Some thenables are not genuine promises though, meaning that they don't follow Promises specifications exactly and can result in tricky errors to debug if mistaken for a genuine promise. An example of not conforming to the promises spec would be calling the callback functions in the wrong order. If a thenable doesn't have .then() or .catch() methods, behaves unexpectedly, or comes from a third-party resource it is reasonable to suspect it is not a genuine promise and there are two approaches to take if that is the case. First, you can simply decide to convert the thenable to a genuine promise by passing it into Promise.resolve(). This will solve the problem, but if you instead want to investigate its validity as a promise then thenable duck typing can be used. This is essentially a way to test whether or not it behaves the same way as a promise does when input into a function that is written to validate behaviour specific to only genuine promises. If it looks and quacks like a duck, then it's assumed to be a duck.

The next big section of the chapter talked about how Promises can also be used as a flow control mechanism. Sequences of asynchronous steps can be chained together to make the program flow in a specific way. This can be really useful because it addresses the problem of our brains being wired to plan information sequentially. Callbacks can be very messy to read when trying to arrange async logic in a sequential manner, but chaining promises together provides an excellent way of doing the same thing. Then .then() method creates a new promise and passes the previous promises value into it which creates a flowing kind of logic. It can have fulfilled() or rejected() methods within it that handle the different states of the previous promise as well. Anyways now im getting into the syntax so im going to shift over to summarizing the Promise "API" instead.

There is a main Promise object that exists by default in Javascript. You can create a new promise instance by using the promise contructor (called with the new keyword). The constructor takes a function as input with two parameters: resolve and reject. Calling either of these functions changes the state of the promise to resolved or rejected which cannot be overridden. Doing so triggers the completion event and returns the corresponding value that is defined by the developer. This pattern is referred to as the revealing constructor pattern because the result of the internal operations are revealed to the external code but cannot be changed by the user. Promise.resolve() and Promise.reject() make new promises that are aleady in the corresponding state when created. It seems a little unusual to resolve/reject a promise immediately when a normal object can just be returned instead, but the benefit is that it ensures the promise is executed asynchronously and therefore gets tossed into the job queue rather than the normal synchrnous call stack. This gives fine-grained control of the order of execution which is just lovely aint it. .then() and .catch() respond to promises changing state and on fulfillment will provide the resolved value to the next stage when applicable or catch an error and bypass the rest of the chain. Promise.all() and Promise.race() take an array of promises and await all of them to return a value or wait for the first to return a value respectively before continuing.

Okay there are obviously more nuances but that sums up all of the important bits! I feel pretty confident after that chapter. I'm sure putting these into practice will knock me down a peg or two though haha. Either way great progress is being made.
