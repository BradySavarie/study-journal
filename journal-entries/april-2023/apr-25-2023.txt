Damnit, I haven't had much free time today at all to work on coding. It's 10pm and i've just finished up everything I needed to do for the day so I guess now is the time to get started haha. On the agenda is learning about balanced binary search trees and then starting to implement one using javascript. Should be fun.

So far i've written a recursive function that builds a balanced binary tree which is pretty neat.
It takes a sorted array as input, and sets start and end variables to default values of 0 and 1 less than the input array length respectively. The base case checks if the start value is higher than the end value (signifying the recursion has operated on the last node of the tree and is now passing over the end of it) and returning null if true to begin climbing back up the tree. Next a midpoint index is calculated for the input array using the start and end variables. A node object is then instantiated with is 'data' property value set to the middle array element. Creating nodes using the midpoint of each recursive call allows for O(log n) efficiency and provides the ability to create a balanced BST since starting recursion from the middle of a sorted array will allow us to traverse left and right in equal proportions (unless the array is an odd number of elements which will result in either the left or right branch having one more level, but this is still considered to be balanced). The left and right properties are set as next using recursive calls that reducing the end value down to 1 less than the mid point if traversing left or increasing the start value up to 1 more than the mid point if traversing right. This builds a call stack that operates on each subtree separately. Eventually the final result that is returned is the root node, while the rest of the nodes have been created and their pointers set to the correct node values.

pretty awesome stuff there!! I then used another cleverly designed (by someone else) utilty function that prints a visualization of the BST to the console, all I have to do is plug the root that is returned into it. My next focus will be on writing functions that actually allow for usage of the tree itself. For example inserting and deleting nodes, finding a particular node given a value, converts traversal to level order instead of depth-first, etc. 