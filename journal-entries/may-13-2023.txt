Alright, time to get started on learning about typescript classes.

Well that was pretty straightforward. Eseentially I just need to initialize the class properties first and define their types. Then, when I use the constructor I also need to define the input type for each since it doesn't know yet that the input parameters will be set equal to the properties on the instance of the object being created. Methods can also be added on as usual, nothing else seems to stray from what i've learned in the past. Instances can also be created normally without needing to define types since they have already been defined in the class. I'm going to go watch a video on access modifiers (public, private, readonly) and then once I understand that topic I will update my battleship code to be in line with what i've learned.

Okay looks like i've found the solution to yesterdays class related problems. Every property/method defined within a class is set as public by default. This means that it can be accessed on instances of the class and the user can make changes to the values if they like. Private on the other hand means that a property cannot be accessed on instances of the object. The values can only be changed and viewed within the class itself. This is nice when you want to only use the properties internally and not have it available to the outside world to prevent errors/unexpected behaviour. Readonly allows the properties to be accessable, but they cannot be changed outside of the class itself. This is handy when you need to see what a value is but it is not a good call to allow it to be overridden.

It turns out that writing the properties out first is the standard way of doing things, but just like in javascript there is a shorthand that lets you create the properties within the constructor function to make things quicker and easier to read/write. I was attempting to use this shorthand yesterday but it was throwing errors. The reaoson for this is that in typescipt you need to explicitly declare the access modifiers of each parameter when using the shorthand constructor based notation. I find this behaviour unusual because it is inferred automatically that a parameter is public when created outside of a constructor function, why not carry that behaviour over into the constructor? Either way this was the source of confusion so I will go fix that now.

Okay i've fixed up my board and ship models now to fit within the confines of typescript. Feeling good. The next challenge to work through is the placeship method on the gameboard. This method needs to take a ship as input and, given constraints, place it on the players gameboard. At this point i'm also considering creating a player model to store information related to each player, such as their gameboard and ships. 

I've just decided to expand upon the current logic to include an orientation feature. This will allow users to choose the orientation of their ships while placing them. I figured implementing this before writing the placeShip method would be smart.

Moving forward now with the typescript series. I've just learned about using modules, however Webpack was not covered so I will need to go do a separate course on that once i'm done this series. I learned that I need to specify which module system I am using in the tsconfig (es6/es2015), and set the target to es6 to compile the js to es6 syntax. This results in only modern browsers fully understanding the code though so that is the first problem. It has also been mentioned that I should add type=module in the html script tag that loads up the javascript. Not sure why or if it is even necessary once webpack is setup. More research to be done there. Once those steps are taken I am able to compile modular typescript, but the second big drawback is of course the code isn't bundled so there are a lot of files bein loaded into the browser which means excess network requests and thus a slow load time. Could do better but i'll come back to it after.

I learned the basics of interfaces just now. They are very similar to classes, but the main difference is that they are not necessaily used to create object instances and therefore does not have a constructor. Instead they represent a custom template for an object. It is like an expansion on the concept of function signatures. For example, say you wanted to create objects that represent people but the people have different characteristics. Like they speak different languages or just behave in different ways. You probably don't want to use a class for this because the same method "speak" would have to function in very different ways. You do however want to ensure that the objects follow the same general format, and they must include that particular speak method and other common properties. Using an interface would be perfect here because you would be able to define a structure for both objects, with the same properties and methods (that have the same signatures), but then can add custom functionality within each of these properties/methods. The speak method can contain logic for one object that results in an english output while the other can be in chinese. When you say an object has the type of 'Person' (Person being an interface), you are assigning it a complex, custom type that it must conform to. It's a blueprint for many different objects that are similar in nature but have certain differences and thus can be used as a starting point for developing those objects. 

Integrating interfaces into class syntax is pretty powerful and easy. You can use the keyword 'Implements' to enforce a class to use an interface. This ensures that each object that is instantiated with the class contains whatever properties/methods are included in the interface. Doing this is like an extra layer of security that helps ensure the objects are following a specified blueprint in some way. A good example is having an interface that contains a format method which dynamically strings together some properties into a coherent message. You can then ensure that some existing classes called invoice and payment both implement this interface (possible called hasFormatter) and therefore have a formatting method by using the implement keyword. This allows both formatting methods to be slightly different depending on how they are written in the class, but makes sure it exists and follows the specified signature in the interface. Cool stuff.