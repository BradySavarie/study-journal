The chapter on Promises is quite a dense read, I had a hard time yesterday keeping focused on it. I managed to solidify the idea that promises a essentially placeholders for values that will be returned at a later in either a resolved or rejected state. A promise can be said to encapsulate the time-dependant state by waiting on a future value to be filled before triggering a completion event, making the promise itself time-independent. This allows promises to be combined with other code in predictable ways regardless of the timing within it. In other words it is much more easily composable than using callbacks, which do not encapsulate the time-dependant state. As quoted in the book, "Promises are an easily repeatable mechanism for encapsulating and composing future values".

Another important note is how Promises do not have the same inversion of control problems that callbacks do. When callbacks are used, we are giving control away to some other piece of code (often 3rd party (untrustworthy!)) and letting it invoke the callback once it is ready to do so. This also inadvertently provides control to the API or whatever to use the callback as they see fit even if it doesn't align with the developers intentions. When everything goes to plan this is fine, but sometimes it becomes a real problem and represents a weakness within the code. With promises however we are making use of a completion event and thus inverting the control back to the programmer because we then get to decide exactly how to use that information. We can invoke a function once the completion event fires, but now the ball is back in our court because it is up to us to take the action. 