Picking up where I left off with the MongoDB lesson. Starting off a a section that teaches me how to output documents into views. Let's goo.

Been having a lot of fun so far working through the creation of a blog site using express and mongoDB. I left off yesterday having setup get request handlers to the blogs page. At the moment I have also setup a post handler to the /blogs route that takes the form data submitted from the create-blog form, creates a blog document out of it that is saved to the database, and the redirects back to the /blogs route that displays all of the blogs. This post method results in adding a blog post to the site.

There were quite a few steps along the way to make that happen. First of all I needed to use a piece of middleware provided by express that is designed to take form data when submitted and put it into a body that is accessible via req.body. the middleware is called urlencoded. Without using it I would not have access to nicely formatted form data. Once I had that data available I created a post request handler for the /blogs route (since the form has the action set to /blogs, which creates a post request to the route) and inside of it I created a new blog entry using the blog model that takes that nicely formatted form data as input via req.body. The form data follows the blog schema perfectly which allows the blog model to make a new blog document without isue. I then saved it to the database and once that async task completes the user is redirected to the blogs route. Pretty easy process overall. 

I also learned how to use request parameters. Each blog document has an id associated with it, so I created a new get handler for the route /blogs/:id. The id is a dynamic parameter so it can change to anything that the user inputs. You can access the request parameters at req.params.nameOfParameter (in this case req.params.id). I stored the result of that in a variable called id and then asked the blog model to find the document by id with that variable as the input. Once it did that I told it to render a details view with the resulting blog. The details view takes the results as input and shows a page using all of the blog properties. I've used url params before so this process was already familiar enough to me to follow without much trouble.

Next I get to learn about delete requests which is another piece of the CRUD puzzle. Unfortunately I don't think this tutorial covers the put method which handles updating documents but i'll definitely need to look into that in the future.

Learning about handling deletes was awesome! This is all so intuitive once you see how it works. What I really liked about this part was the communication between the back-end and the front-end. Running my own server is a great thing.

So I created a link in the details page that has a data attribute on it called doc with the value set to the id of the document. Since the goal is to respond to a click of the button, we first have to deal with the front-end which will send an ajax request to the server as a delete method. This basically just says 'hey server, i want you to delete the document that matches this id. You can use the fetch method to send this request. The first parameter of the fetch method is the endpoint that you are sending the request to. The route that we want to send the delete request to is /blogs/:id, so we can create a variable called endpoint in the front-end that inserts the current blog id. You can do this within a click event listener on the delete button, and insert the fetch in there as well so it only sends the endpoint as a delete request in response to a click. Boom now you can move your attention over to the server for a moment.

On the server we want to create a delete request handler on that route /blogs/:id. When they request is receive we extract the id from req.params.id andactual delete the document from the database using the blog model with the method findByIdAndDelete(id). When this async task completes we send a response to the browser. What we want to happen is to redirect the user back to the /blogs route. We can't do this strictly on the back-end because it is an AJAX request which expects a response back in a form it understands, such as json. So what we do is send a response with the json method and inside of it include an object with a redirect property to the route that you want the front-end to redirect the user to. This looks like res.json({ redirect: '/blogs'}).

Back at the front end now, the fetch request receives the response from the server and parses the object as json. This happens asynchronously as so we are chaining then methods throughout the process. The response that we end up with is a json object that we can call data. What we can do to redirect on the front-end is just set the window.location.href property to the data.redirect value. Make sure to catch all of the errors and this whole sequence of events will delete the document and redirect the user back to the main blogs page once the delete button as been clicked. Really cool stuff.