I had the opportunity to spend quite a bit of time throughout the day going through the new React course and i'm back at the shopping cart application again. I came across a handful of new, interesting concepts in these updated lessons as well that i'll go through quickly.

I read the React docs about choosing state structure and sharing state between components which helped identify best practices regarding how to store data in state more effectively and how to manage the one way flow of data through different component levels via lifting up state. Just review for the most part but it was helpful to go over all of the concept to see what stuck and what didn't from putting this all into practice. I did a couple of little code sandboxes to test my ability to lift state up and I had no issue with it at all so i'm pretty secure about that.

Next I went a bit deeper into using effect. The new lessons on this is so much better than before! I understand now (and this is a big mental shift) that effects should not be though of as part of a components lifecycle thats happening at any given point but instead as a synchronizing mechanism that has a start and stop. The purpose of an effect is to synchronize a component with some external data as it changes. Using a basic fetch for example: it should start synchronizing when your component mounts and it should stop synchronizing when your component unmounts. If there url is dynamic than perhaps you will want to re-synchronize your effect whenever a change to the url is made. That changing data becomes a dependency and so it is added to the dependencies array of a useEffect hook. This tells useEffect to resync when the data changes (stop sync and start again to use new data). This is a much better mental model to use when thinking about effects than trying to look from the component perspective and understanding where in the components lifecycle it is taking place. I also learned how important the clean up function is an a useEffect! I underestimated it's importance last time I went over it and didn't realize that some bugs can be caused when certain effects aren't cleaned up whent he component unmounts. useInterval for example will keep running if it isn't cleared and could be a source of confusion, so it's important to clear that up when the component unmounts.

Another point on effects: they aren't always necessary and should only really be used when you are syncing with an external system aside from props and state. Always ask that question when deciding if you should use one. What is being reacted to exactly? It's important to figure that out before writing as useEffect because many times when you want something to happen at a certain time it can be accomplished by making calculations outside of any effect or by lifting state, etc. Don't use effect for events - just because you are reacting to something does not mean it requires an effect. Use a function that responds to the event for this (perhaps that updates states and triggers that required rerenders).

The sections on class components and testing all are pretty much the same as before which is nice. Only appreciable difference is that Vitest is being used now in the course however i've already gotten acquainted with it so that doesn't change much for me.

I read a little bit about propTypes which is nice. Its basically just a little library that allows for type checking natively using objects as interfaces pretty much. It's like a bare bones version of typescript. Cool to know it's available but I don't have much use for it since i'm already working with typescript consistently.

Here is where things got interesting. The React Router lesson was updated and described the new suggested way of client-side routing. This involves instantiating a router object using the create<type>router hook and then using a router provider to actually render those routes out. This is functionally the same as using just the regular components but gives access to newer features compared to that. It's best to create a router.js file to encapsulate all of the router logic in itself to keep things clean. So it will just return the router provider rather than the whole router object cluttering up main.js where the router is rendered. In addition to this, nested routes seems to be an important part of the puzzle that I overlooked. You can create nested routes using the children key in a router object. A child route is rendered along with the parent route when the url matches it's path. This is pretty awesome because it allows multiple components ro be rendered together when nested within eachother. You can use an Outlet component to take control of these nested routes. When a component that contains child routes has an Outlet component within the JSX that it returns, the Outlet basically just returns whatever that valid element is within the child route that is active. So if we're in a parent element and it contains a child route with the path /dog that render a Dog component, than when the url is parent/dog you will see both the parents jsx along with the dog components jsx being rendered together. Beautiful. You can use an index key with a specified element to tell the router which element to render by default. Dynamic segments work the same as before, just use a colon to name the segment in question and then access it via useParams. Error handling is covered by providing an element to render when no match is found. Just insert a errorElement key, similar to an index key.

A really good lesson was all about data fetching in React. This was not touched upon at all previously and there is a bit of nuance to it that i didn't previously recognize. Fetching works as usual, just return a promise that either resolves or rejects and use try or catch blocks on the results to handle successes or errors. response objects that are returned from fetches will have properties called 'status' and 'ok' which can be used to set custom error messages as well if they return any http codes that represent an error or are falsy, respectively. These fetches should likely be wrapped up in a useEffect though with an empty dependecy array so they only run on mount. You can also write a custom hook and include all of the fetching inside of it that returns data, error, and loading states as those are the cases that need to be handled when fetching data. Alternateively, libraries exist that do all of this for you! Tanstack Query (formerly React Query) is a great data fetching library that really cleans this whole process up and offers great data fetching/management capabilities. It will be worth learning. I also learned that Axios provides enhanced fetching servies that handle all sorts of possible problems automatically for you rather than having to deal with certain errors and what not yourself related to fetching. you COULD write your own code to handle all these types of possible errors like no server response, bad data returned, etc. but Axios can help do that for you.
