Todays goal is to complete the typescript series that i've been watching on YouTube, and i'd like to make some serious progress on the models portion of the battleship project. This could mean writing the placeShip method in it's entirety and working out how I want to organize the modules (players and game state still need to be figured out). I may get sidetracked though which is acceptable. I want to avoid getting too caught up in the project to not learn anything outside of it. I find i've been rushing my way through the last few projects just to make progress in the course but I need to keep reminding myself that i'm not under any sort of time constraint for course completion. The point is to increase my skillset as much as possible and I think that straying from the path every now and again when I identify gaps that need to be filld in my knowledge may prove to be valuable.

I've made quite alot of progress on the battleship program so far. I've written the player module that creates a new gameboard and a ships array and stores it in a player object. I've also installed ts-node globally so I can use node to run my typescript at any point in time. I ran into any issue with my the module system not compiling correctly but i've backtracked far enough now to remove the problem. I'm not sure why it was happening, but whenever I would try to run code inside the index.ts file the contents would get printed to the console immediately even the I had no log statements written out. I have yet to actually figure out what the deal is with this but I figure it may not even come into play once I am bundling everything with Webpack so I am going to move forward until I encounter it again. Next up is completing that Typescript series. Once that is done I can circle back to battleship and start attacking the placeShip method as I think that is the next problem that needs solving.

I've learned about generics in typescript. The concept is still a little fuzzy so i'm hoping by describing it I will be able to identify my knowledge gaps. A generic is a placeholder variable that represents a type without actually having to know what the type is. They are used when you want to create a function, interface, class, etc. that is reusable for different data types rather than locked in to something specific. In the context of a class for example, it can have a generic type parameter and that generic type can be applied through the class as necessary. Then when an object is actually instantiated using that class the generic types parameter value will be specified. This seems similar to using the 'any' data type since a generic represents a type that we don't know, but it is better in that it doesn't completely sacrifice the benefits of type safety yet is still flexible.

The syntax of generics is a little odd but I think i've got it down. When a generic parameter is defined it is written within angle brackets directly after the name of whatever it is being attached to. The convention is to call this particular parameter T, but just like any variable it can be named whatever you want. For a Person class, the syntax would look like class Person<T> { etc. }. Within the body of the class that value T would be used wherever you aren't sure what the type should be yet. Then when instantiating the class the syntax would be new Person<string>() if you want the generic to be set as a string type. A helpful example that I read was thinking of a toolbox that can contain whatever tools you decide, you aren't quite sure what will be in it yet. Later you decide you want it to contain wrenches, so you specify the generic type of tools within the box to be wrenches.

The next concept that i've studied today is enums. They are another data type unique to typescript that allow you to specify a set of keywords/constants that are associated with a numeric value. This is comparable to an array, however with an array you always refer to the element by its index. With an enum is it the opposite, you can instead refer to it by it's keyword and the index will be associated with it. This is great because it is easier to work with values as a human when they have some sort of descriptive meaning to them that help identify at a glance what they are rather than looking them up with an index. Computers however manipulate data better in many circumstances when it has a simple identifier such as an index number to use to reference a value. Using enums you can specify that a type of resouce for example is a book, or a film, or whatever other resource types are available in the set. Then the resource that is assigned that type will actually be given the index number to do any calculations or whatever with. If you logged resourceType.book to the console and book is the first keyword in the enum set ResourceTypes, then the value logged to the console would be 0. Search descriptively, return an index.

Tuples are the final built-in data type that is mentioned in this mini-course. They are arrays but with a catch: the data types of the elements cannot be changed once set. In typescript when a normal array is defined and it contains elements of different types it is inferred that any value in the array can be of any type so long as it is included in the array already. If the first element is a string and the second is a number, you can later update the first element to a number because that data type exists in the array and therefore it is inferred that it is okay to use that type. A tuple however would not allow this. The values can only be changed to match the data type that was initialized in that particular position. So that first string element could not be changed to a number, but it could be changed to another string. This is interesting because it ensures that the position of the data types do not get messed with. Say you had a student array with a name property and student number property. First type is a string second type is a number. Is somebody made a mistake and input the student number first when creating a new entry this would be accepted in a normal array. A tuple would catch this error by not allowing the change to be made since it is the incorrect data type for that position in the tuple. Bug squashed pre-birth.