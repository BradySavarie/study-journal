In continuation of yesterday explanation of how the color mode toggle works in this application:

Okay so now we have access to a Theme object that is updated everytime the mode changes, and the mode can be changed via a toggleColorMode function. We need to provide this theme object to our whole application now so that it can actually be used. We do this using context. 

To manage the theme context i've created a seperate module called ThemeContextProvider. This module creates a new context that is initialized as an object that has theme, mode, and toggleColorMode properties built in to it (notice that it has the same structure as the color theme object). The properties have default values so they match their type interface, but these values will be overridden. Rather than reinitializing the context everytime it is  used in the application (which asmittedly isn't much, but still, good for scalability and readability) we make a custom hook for it that is exported called useThemeContext. We now need to provide the context to all of its children by wrapping it in a provider, but rather than do that outside of the module we will instead export a custom ThemeContextProvider component that handles this internally. This is where we call the useColorTheme hook created earlier since we want the theme object that is currently active to be passed down as context! So we call the hook and store its return value in a variable. From this provider function we are returning the ThemeContext's complimentary provider component with the value property set to the theme object value that was stored. Inside of the provider we pass the children variable to ensure that everything is wrapped(for reference, this looks like: <ThemeContext.Provider value={value}>{children}< /ThemeContext.Provider>).

At this point we have a theme context that can pass it's data into the application containing a theme object, the current mode, and a function that toggles the mode. All we need to do now is make use of this system. Start by wrapping the entire router with the custom theme context provider that we wrote so that the entire application receives it. Next you can go into app.js, call the useThemeContext hook to access that all important theming data, and wrap whichever components you like with mui's ThemeProvider component using the theme object from our context as the theme property value. In this case I want the entire app to change when the mode is toggled of course, so all of the jsx in my application will be provided the theme by being wrapped. One little quirk to keep in mind that some things aren't affected by default when the mode changes in mui, such as the apps background color. If you want that to also be affected by the theme you will also need to include the CssBaseline component inside of the theme provider here so that is receives the value and can use it to set it's values based upon it. Doing this will ensure everything gets styled as intended.

All that's left to do is add the toggling functionality in the navbar. This part is comparitively simple. Just destructure the mode and toggleColorMode properties from the object that the useThemeContext hook returns. Then in your jsx you conditionally render icons depending on the value of mode (light icon for light mode, vice versa). These icons are placed inside of an icon button that has it's onClick property set to the toggleColorMode function. That's all that's to it. 

So now when the icon is clicked the mode will be toggled, creating the correct color theme object and sending it into the theme context which is provided to the whole application causing everything to rerender with the updated values (all colors will change and the icon that is conditionally rendered will change). That's how dark mode in mui works! Design functions that conditionally return theme objects, custom hooks that make use of them, context that provides data to the app, and the application tha renders based on its value.. all controlled by a single click. Beautiful.
