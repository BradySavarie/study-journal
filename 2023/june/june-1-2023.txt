Okay time to slay the final boss. All i've got left in battleship is to create the computer AI the decides which coordinate to attack. A few unrelated words on testing before jumping into that though.

Testing has been on my mind quite a bit. I felt that as the program went on I started to neglect writing tests, however after thinking about it I am confident that I wrote the tests that mattered for the time being. None of them relate to rendering which was the focus for the past little while which is why I felt like I was slacking. I have tests for every function that currently seems like it should be tested which is great. Of course this is literally my first time doing this so I could be way off base but I don't feel lost and that is a good sign I believe. On my radar right now is that the tests aren't as pure as they could be in some cases which leads me to believe that I should be extracting out more code to clean things up. They are also more coupled than I would like. I'm sure improved designs will come with time and experience but I am at least aware that problems do exist. I should read that book "Clean Code" that peopl keep on recommending online - apparently it has a testing section in it as well that could help. Last night I had written my first mock function in order to get around the issue of not having the document object available to run tests with. Some solutions online recommended configuring jest to use a different testing environment than node but that didn't work so I figured a mock would be an okay alternative. I wish I understood the source of the problem a little bit deeper though. It still leaves me asking if the test itself was low quality by even runnning into that issue as I didn't think it needed access to the dom in the first place. Also, I learned that the describe function in Jest is used to group together blocks of related tests so I can refactor. the It function is an alias for the Test function as well which is nice to know. it just makes the syntax read in a more fluid, english-like way. Finally, I would like to expand my knowledge of matchers rather than stick to the basic "toBe" option. Apparently toBe uses Object.is to test exact equality so it is pretty strict which is good, but there are alot of other matchers that would better suit different use cases and being aware of them and ready to use them would be beneficial.

Alright tonight was fairly successful. I've written out my 'pseudocode', wrote the first couple of tests, and then wrote the function to make them pass. I've had the chance to refactor old tests to fit it statements inside of describe blocks, and i've used a more specific matcher. Formulating a plan, writing tests that assert the behaviour of that plan, and THEN writing the code itself is a very nice workflow. It makes sure you understand and every step throughout the process what exactly needs to be done. An argument could be made for it slowing down the development process, but it's hard to quantify the time it saves in debugging down the line so is TDD really wasting time? Perhaps on small projects, and if you are testing the wrong things in elaborate ways, but this seems to offer a lot of benefits outside of those situations.