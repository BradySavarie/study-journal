Today I would like to work out 2 remaining problems with the api fetch code that I have written. First of all, I am unsure why the code returns the movies array with 25 objects when I save my code while the dev server is running yet when I hit refresh it only returns an empty array. Second, I am still getting a linting error. 

Alright both issues are fixed. I added a loading state that is initially true, which conditionally is rendered to display a loading screen. Once the data fetch is completed the loading state is set to false and the actual program will be rendered instead. I removed the rawMovieData state completely by opting to call the generateMoviesArray method within the api fetch function instead which simplified things further. Now whenever the page is refreshed the state of the movies array is updated to the newly returned json object without triggering another rerender in between. Works good. I see the loading screen and the returned data so no issues there. The linting error did persist so i've disabled it for that line. It is asking me to pass in a function as a dependency which causes an infinite loop so that's not going to fly. Can't find another way around it but since everything is working I think disabling is an okay way to go.

Now i've got to figure out what to do next. I suppose the next accomplishment would be to have an unstyled version of the first round of the game be displayed. In order to do this I will need to setup a few components: I will need my cards to display the information, a card container to hold the cards, and a timer that displays personal best and current scores. Come to think of it, I can probably forego the container at the moment too as that just serves a styling-related purpose. 

So timer or card first? It will be easier to test the timers functionality when I have a card component so I think starting with the card makes the most sense. First of all I will need to write a method that identifies how many cards will be shown. The number of cards shown depends on what round it is, so this method will need access to a variable representing which round is being played. Round will therefore need to be saved in state and initialized to a value of 1. It should be kept in app.js since that is the component that will render the cards.


That was a really fun coding session. I ran into a couple interesting problems. The first thing that I did was write a quick function to store only the movies being used for the current round in state. There wasn't much to that. After getting it working I wrote some jsx that maps out a new array and creates a card out of each movie object in the movies stored in the currentRound array. This will obviously be moved into it's own component but it is just to temporarily visualize what is going on.

Once I got that up and running I ran into a problem where a portion of the poster URL's from the api were not loading up because the link was broken. I decided to get around this by cleaning the data before sending it through the application once it was fetched, that way only movies that contain working links would be considered. I did this by writing an async function that catches loading errors, only pushing each movie into a clean array if it did not throw the error. This created an issue in a function down the line though because I now was querying for id's that did not exist in the new data set. To get around this I had to randomize an array of numbers the size of the returned data using a lodash library, and then check if any movies have an id matching each randomized number. I continued this until the movies array had 26 movies in it (1 extra for the first round since two need to be shown to start). 

The result of all of that today has been movie titles and posters being rendered in a quantity dependant on what round the user is currently on. Perfect. 

Next I will need to create the actual card component to hold the jsx. Then I can make a timer to track the users score, as well as write the functionality required to move to the next round. I am already seeing the light with this project. What i've loved about it so far is that it is making me much more confident that i've retained enough information about writing async code and using api's which are both very important topics. Feels good to work those muscles.