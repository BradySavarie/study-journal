Today at work I was able to spend a bit of time reading through the mocking lesson from TOP. I have some additional assignments to do however I think I have a handle on the main concepts there. It is pretty much the same as when I learned mocking in Jest.

So far the most helpful piece of information i've gathered on testing as it relates to understanding the workflow behind it is how to follow the arrange, act, assert pattern. Arranging refers to setting up all of the necessary elements/props/etc that need to exist in order for a certain test to take place. Acting is actually taking the action that you are trying to test. Asserting is stating what you expect to happen and then comparing the result with that expectation. For example, perhaps the test that you want to write is whether or not a button changes it's text to a particular value when clicked. First you would arrange the test by setting up a userEvents object and querying for the button. Next you would act by triggering a click event on the button. You would then assert by comparing the result against expectations.

I also decided to take on a side quest to understand Reacts context API as it seems to be cropping up alot in the code i've been viewing recently. I am currently in the middle of a video that is describing how to use the api as well as the pros and cons associated with it. The main problem that is being solved with this api is that prop drilling (manually passing props through several layers of components to reach a target component) is a messy way of handling state management, especially as it increased in complexity. It created unorganized code and requires a lot of manual entry that can cause bugs easily, not to mention it triggers a bunch of unnecessary rerenders because each component will render again when the prop changes even if that component isn't even using it. WHy would you want to pass a prop into a component that isn't using it anyways, right? The only downfall that I can come up with myself (without watching the cons section of the video!!) is that it makes the code less direct and anybody that works on it will not recognize immediately what values are being passed since the chain isn't visible to them.

I understand how to create a context and use a context provider to pass values down to all of the child components within it. It works the same as a themeProvider in materialUI (actually im pretty sure that is built using the context api). When you actually want to use the context you can just destructure the useContext hooks return value, extracting out the context value that you want to access. Some apps will use many contexts so you need to tell useContext which one you plan on using by including it as an argument. The return value is of course the context object containing all of the values you have set inside of it.

The best practice for actually working with contexts is by creating a custom provider component for it that encapsulates all of the context based information within it. So lets say you have a social media application that needs access to the users information in many different parts of the app. The most obvious option would be to just keep the context in the parent component along with all of the logic that makes changes to it, and then wrap the components that you want to receive the context with its provider. This can clutter up the parent component though pretty easily by containing all of the logic within it that relates to the context. Instead you can choose to abstract out that logic into a custom context provider component. You just make a new file, for example UserContextProvider, and then create a UserContextProvider component within it. The component will accept it's children as an input parameter (any elements that are nested within it will automatically be recognized as children and be passed in if you include the { children } object/property). Outside of this component but within the new file you can create the context you will be working with, UserContext. The UserContextProvider will contain all of the state that you want to be included in the context for use in the child components. In this case there could be state that stores values representing authentication (true or false, is the user authenticated?), or just basic user information in an object (with keys such as username, password, etc). There could also be methods that make changes to the state (such as a login method that fetches user information and stores it in userInfo, and then sets authentication to true). Finally, all of the values are then grouped together in a final 'values' object, packaged together neatly and ready to be sent to all of the child components. The component will return the actual context provider now (not that custom component being created), send the values object in as a prop to it, and wrap the children prop in this provider. This approach does the same thing as the first method but it keeps all of the logic encapsulated within the single component file.

So now i've learned about the cons of using the context API. Many people misuse it by including states the are prone to changing often, which then triggers a rerender on every single component that receives the context. This can be terrible for performance and is really not necessary at all. The fix would be to only use context for states that are not subject to alot of change and therefore won't require a bunch of rerendering. This would mean passing in global states such as isAuth to represent that the user is authenticated. Your app may need access to that in a lot of different places, but its not like that value will change very often at all. This is the use case for context. If you have variables that may change on occasion but you need access to them still in certain sections of the app, a consideration to make would be creating a new context for them alone and wrapping it around only the section of the app that needs it. This would keep the rerenders more in balance, but it still isn't ideal of course as sections of the app will be rerendering when it doens't have to. For that reason you can actually just go ahead and prop drill sometimes to prevent that if you deem that the trade-off is reasonable. Prop drilling is not a great technique but it's not the worst thing you can do either so keep in mind that it is okay to use when you deem it is a smart move.

Finally, it will likely become better overall (some may argue its overkill though) to use a state management library such as Redux when context and prop drilling doesn't handle state needs very well. The creator of the video I am summarizing mentioned that an alternative to a big state management library that he prefers is using fetching libraries with built in state management (React Query in particular). I don't entirely understand why this is his take on things because I have not studied these external libraries at all yet, so i'll leave that open-ended for now.

Okay I learned about the act api in Jest, which ensures that the timing of state management and effect usage is managed so that any assertions you make will take them into account. This is important because useEffect only runs after a render, and state wont update until it is told to which will be at least after the first render of a component. When you run assertions though they will happen directly after the render and therefore will miss out on the changes that the useEffect and states create. This can give bad test results. The act api queues the assertions to take place after the state and effect changes just by wrapping the actions that you are making assertions on within it. It basically reorganizes the queue so that your testing runs after everything has already happened which is handy. Act api also lets you write async tests.

I also learned about mocking components. When you have a complicated child component that erquires a coupled steps of setup to get to the state that you want to test within the parent you may want to consider mocking the child component. You basically just want to create a stripped down version of the component that has the same api as the regular one but returns values as if the 'ceremonial' process of setting up has already taken place. This allows you to skip the extra steps involved so that you can get right to testing the actual thing that you want to test. Pretty cool. I need to take testing seriously in this upcoming project so that this information really locks in! They are not exactly fun to write however they are highly valued in the industry and serve a purpose so I need to get more used to writing them, esecially mocks as I don't think i've employed those yet in any projects.

Anyways i've just moved on to the shopping cart project, lets go! I'm excited for this one.