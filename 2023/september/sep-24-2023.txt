So I ended up doing a little bit of research yesterday after failing to deploy my small project and it turns out that i'm not the only one who always runs into issues with deploying projects. It's actually an entire job in and of itself to manage the process, and is a huge part of dev ops. This makes me feel a little better because I recognize that whenever it is time to deploy I am always trying to rush through it as quick as possible to just get it done, but the truth is that it is a skill I will need to actually stop and focus on learning if I want to really get good at it and understand the process thoroughly.

Anyways, as mentioned previously I am going to follow the direction of the MDN tutorial series to host my project which will walk me through the basics of what I need to know. For now though I am learning about routes and controllers. Let's go.

Cool so I finished up the routes and controllers lesson. Mostly a contained information that i've covered in the past but a good review nonetheless. I basically setup a catalog router that responds to all of the routes that my application will be using. A controller function is called for each different route. The controller functions are split into modules based on the models that will be used within them. So one controller for book, one for genre, etc. Each of these controllers contain all of the related functions within it which is a nice to way organize the application. Since we can assume that the controller functions themselves will interact with a database and will therefore by asynchronous we can wrap them in a piece of middleware called express-async-handler. This function has built-in error handling that forwards the err to the next pieceof middleware as it occurs so that it can eventually be handled by a global error handling function. We would otherwise have to write the error handling using a try-catch block within every single controller function which would get a bit tedious. I also learned that route matching can make using of string patterns and regular expressions instead of just basic hard-coded routes and route parameters. This can extend functionality quite a bit so i'll keep that in mind in the future.

Now it is time to move on to the next lesson where I will be learning how to actually display the library data using the controllers and models that i've created. This is a longer lesson that happens to be split into sub-lessons, so i'm expecting I will also be creating the views as well which means learning how to write PUG code. 

Checking back in after putting a few hours in. This has been a really fun lesson. I've been writing controller functions that use Mongoose to query the database for information using the models that i've set up. Then once I receive a response I render a pug template using the response as dynamic variables within it. The pug templates are all separated out very much like ejs partials, but in the case of pug it just extends a base file that I called layout. You just need to specify in each file that it is extending the layout file and overriding the content block. Easy stuff. So far I much prefer using PUG to ejs actually, the syntax does not look like html but it is so mch easier to write in my opinion. I think i'm probably going to stick with it. I also have been getting used to creating virtual properties on models which are basically just a way to add data to a model without sending it to a database. Instead it can make use of the properties in the model to calculate it's own values. Right now i'm using it to format some existing properties using a third-party formatter library called Luxon.