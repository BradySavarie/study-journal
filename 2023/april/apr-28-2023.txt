yesterdays work ethic was... questionable. Fell asleep after maybe 40 minutes of working on the delete function. Not proud of that so i'm skipping the bars tonight and starting to conquer this binary tree nice and early. Got an americano in front of me and im not afraid to use it.

So I had managed to create the majority of the function before passing out. It is a recursive function that takes a value as input and searches through the tree until it either hits the base case(a node with a null value) or the value matches an existing node within the tree. If the base case is reached the root is returned. The root is returned instead of null because the root of the tree being searched is set to the return value of the function. If null would be returned by the base case the entire tree would in essence be deleted. If the value is matched we first check if it's a leaf node by seeing if both of its child values (left and right) are null, then we check individually if only one child is null to see if perhaps the node is a single child node, then finally its assumed that it is in fact a two child node and a script is run. If it happens to be a leaf node then null is returned to ensure that the node in question is removed entirely. If only one child is found to be null, the opposite child gets returned because that is the value that you want to replace the node with when deleting it. 2 child nodes is more complicated and that is what i'm currently working on now. Will report back once I lock it down.

Okay so the idea for deleting a two child node is to replace it with it's inorder successor. The inorder successor is the minimum value node in the right subtree of the root. So basically traverse to the right and then continue traversing to the left until a leaf node is reached. Replace root with said leaf node and then delete the leaf node.

NICE. I got the method working (with alot of help from external resources, but still I understand it so whatever). I used a helper function to return the minimum value node and passed in the right node as input for it. I then replaced the value of the node to be deleted to that minimum value. Once that was done I still needed to remove the min value node so I called deleteNode using the min value and right node as input. This traversed down the right subtree finding the min value node which was then set to null using the base case since it's a leaf node. Does that make sense? I think so... basically I replaced the node with the inorder sussessor. Boom.

That was awesome, what a fun little problem to sort out. Recursion is mind-bending in a fantastic way. Time to move on to some more methods.

Now i've written find and levelOrder methods as well. Find was simple, literally just recurse through the tree same as the other methods and compare the node values against the input until a null node is reached. LevelOrder was more interesting. I used an array to create a queue with the root as the first and only element. A while loop would remove the first element in the queue using the shift() method and push it's value into a results array, then check if it's left and right children have values and push those nodes into the queue. This continues until the queue length is no longer greater than 0. A callback parameter is intialized to null, but an if statement passes the current node in to the callback on each loop if it is not equal to null. Pretty neat stuff.

Just finished up writing preorder, inorder, and postorder. That should be the hardest parts completed. I'm enjoying working with this data structure, I do admit though that is is humbling me haha. I've needed to use quite a lot of help sorting out the logic behind these methods. I'm considering writing them again from memory just so I can be sure I really do know them, however time is a valuable resource right now so maybe it's better to keep moving and just knowing that I do understand how to approach solving these problems when the need arises regardless of if I need to research implementation details again. Hm, i'll think on that.

Anyways though i'll run through the last functions I wrote. Basically it is depth level traversal that prints the node values to the console in different orders. Preorder prints the root node value first before moving to the left and then the right, inorder prints root node after the left but before the right, and post order prints the root node last. Implementing this was recursion again, setting a base to case to check if the root is null and returning it if so. I used a result array to store the values for printing when the recursion is done. depending on which of these function are being run the following steps are taken in a different order (the following is for preorder):
    - push root value into results array
    - check if left child exists
        - if so, call itself recursively with the left node as the root and push the return value into the results array
    - repeat last step but for right subtree
    - return results array
Since I want this function to also be able to use a callback if added a line following the pushing of each root node value that checks if the callback is truthy and if so sends the corresponding root ode into it as a parameter.

Height and depth are now taken care of. All i've got left to do is create the isBalanced and rebalance functions and i'm all set. Maybe write up the driver scripts as requested to make sure evrything does in fact work well, although I have been testing so I am confident in what is there. Great productive day.

